{"ast":null,"code":"var sqliteParser = require('./sqlite3_parser');\n\nvar Driver = require('../driver');\n\nvar dbInfo = require('../db_info');\n\nvar sqlite3 = require(\"sqlite3\");\n\nvar SqliteDriver = Driver.extend({\n  init: function () {\n    this._super();\n  },\n  tableToDbInfo: function (tree) {\n    var results = {\n      name: tree.tableName,\n      columns: {},\n      indexes: {}\n    };\n\n    for (var i = 0; i < tree.columns.length; i++) {\n      var col = this.columnToDbInfo(tree.columns[i]);\n      results.columns[col.name] = col;\n    }\n\n    return results;\n  },\n  columnToDbInfo: function (columnDef) {\n    var results = {\n      name: columnDef.name\n    };\n\n    if (columnDef.type == 'INTEGER') {\n      results.type = dbInfo.INTEGER;\n    } else if (columnDef.type == 'TEXT') {\n      results.type = dbInfo.TEXT;\n    } else if (columnDef.type == 'REAL') {\n      results.type = dbInfo.REAL;\n    } else {\n      results.type = dbInfo.UNKNOWN;\n    }\n\n    for (var i = 0; i < columnDef.columnConstraints.length; i++) {\n      var columnConstraint = columnDef.columnConstraints[i];\n\n      if (columnConstraint == \"PRIMARY KEY\") {\n        results.primaryKey = true;\n        results.notNull = true;\n      } else if (columnConstraint == \"NOT NULL\") {\n        results.notNull = true;\n      } else if (columnConstraint == \"AUTOINCREMENT\") {\n        results.autoIncrement = true;\n      } else if (columnConstraint == \"UNIQUE\") {\n        results.unique = true;\n      } else if (columnConstraint.name && columnConstraint.name == \"DEFAULT\") {\n        results.defaultValue = columnConstraint.value;\n      } else if (columnConstraint.name && columnConstraint.name == \"COLLATE\") {\n        results.collate = columnConstraint.value;\n      }\n    }\n\n    return results;\n  },\n  indexToDbInfo: function (tree) {\n    var result = {\n      tableName: tree.tableName,\n      name: tree.indexName,\n      columns: tree.columns\n    };\n    return result;\n  },\n  getInfo: function (opts, callback) {\n    var self = this;\n    var db = opts.db;\n    var createdDb = false;\n\n    if (!db) {\n      db = new sqlite3.Database(opts.filename);\n      createdDb = true;\n    }\n\n    db.all(\"SELECT * FROM sqlite_master\", function (err, rows) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      var results = {\n        tables: {}\n      }; // clean up sql\n\n      for (var i = 0; i < rows.length; i++) {\n        if (rows[i]['sql'] && !rows[i]['sql'].match(/;$/)) {\n          rows[i]['sql'] += ';';\n        }\n      } // process tables\n\n\n      for (var i = 0; i < rows.length; i++) {\n        if (rows[i]['type'] == 'table') {\n          if (rows[i]['sql'].match(/sqlite_sequence/)) {\n            continue;\n          }\n\n          var tree = self.parseSql(rows[i]['sql']);\n          results.tables[tree.tableName] = self.tableToDbInfo(tree);\n        }\n      } // process indexes\n\n\n      for (var i = 0; i < rows.length; i++) {\n        if (rows[i]['type'] == 'index' && rows[i]['sql']) {\n          var tree = self.parseSql(rows[i]['sql']);\n          var idx = self.indexToDbInfo(tree);\n          results.tables[idx.tableName].indexes[idx.name] = idx;\n        }\n      }\n\n      if (createdDb) {\n        db.close();\n      }\n\n      callback(null, results);\n    });\n  },\n  parseSql: function (sql) {\n    var errorOffsets = new Array();\n    var errorLookaheads = new Array();\n    var errorCount = sqliteParser.parse(sql, errorOffsets, errorLookaheads);\n\n    if (errorCount > 0) {\n      var errstr = \"\";\n\n      for (var i = 0; i < errorCount; i++) {\n        errstr += 'Parse error near \"' + sql.substr(errorOffsets[i]) + '\", expecting \"' + errorLookaheads[i].join() + '\"\\n' + sql;\n      }\n\n      throw new Error(errstr);\n    } else {\n      return parserResult;\n    }\n  }\n});\nmodule.exports = SqliteDriver;","map":{"version":3,"sources":["C:/Users/adamj/OneDrive/Desktop/crwn-clothing-app/node_modules/db-info/lib/drivers/sqlite3.js"],"names":["sqliteParser","require","Driver","dbInfo","sqlite3","SqliteDriver","extend","init","_super","tableToDbInfo","tree","results","name","tableName","columns","indexes","i","length","col","columnToDbInfo","columnDef","type","INTEGER","TEXT","REAL","UNKNOWN","columnConstraints","columnConstraint","primaryKey","notNull","autoIncrement","unique","defaultValue","value","collate","indexToDbInfo","result","indexName","getInfo","opts","callback","self","db","createdDb","Database","filename","all","err","rows","tables","match","parseSql","idx","close","sql","errorOffsets","Array","errorLookaheads","errorCount","parse","errstr","substr","join","Error","parserResult","module","exports"],"mappings":"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","sourcesContent":["\r\nvar sqliteParser = require('./sqlite3_parser');\r\nvar Driver = require('../driver');\r\nvar dbInfo = require('../db_info');\r\nvar sqlite3 = require(\"sqlite3\");\r\n\r\nvar SqliteDriver = Driver.extend({\r\n\tinit: function() {\r\n\t\tthis._super();\r\n\t},\r\n\r\n\ttableToDbInfo: function(tree) {\r\n\t\tvar results = {\r\n\t\t\tname: tree.tableName,\r\n\t\t\tcolumns: {},\r\n\t\t\tindexes: {}\r\n\t\t};\r\n\r\n\t\tfor(var i=0; i<tree.columns.length; i++) {\r\n\t\t\tvar col = this.columnToDbInfo(tree.columns[i]);\r\n\t\t\tresults.columns[col.name] = col;\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\t},\r\n\r\n\tcolumnToDbInfo: function(columnDef) {\r\n\t\tvar results = {\r\n\t\t\tname: columnDef.name\r\n\t\t};\r\n\r\n\t\tif(columnDef.type == 'INTEGER') {\r\n\t\t\tresults.type = dbInfo.INTEGER;\r\n\t\t} else if(columnDef.type == 'TEXT') {\r\n\t\t\tresults.type = dbInfo.TEXT;\r\n\t\t} else if(columnDef.type == 'REAL') {\r\n\t\t\tresults.type = dbInfo.REAL;\r\n\t\t} else {\r\n\t\t\tresults.type = dbInfo.UNKNOWN;\r\n\t\t}\r\n\r\n\t\tfor(var i=0; i<columnDef.columnConstraints.length; i++) {\r\n\t\t\tvar columnConstraint = columnDef.columnConstraints[i];\r\n\t\t\tif(columnConstraint == \"PRIMARY KEY\") {\r\n\t\t\t\tresults.primaryKey = true;\r\n\t\t\t\tresults.notNull = true;\r\n\t\t\t} else if(columnConstraint == \"NOT NULL\") {\r\n\t\t\t\tresults.notNull = true;\r\n\t\t\t} else if(columnConstraint == \"AUTOINCREMENT\") {\r\n\t\t\t\tresults.autoIncrement = true;\r\n\t\t\t} else if(columnConstraint == \"UNIQUE\") {\r\n\t\t\t\tresults.unique = true;\r\n\t\t\t} else if(columnConstraint.name && columnConstraint.name == \"DEFAULT\") {\r\n\t\t\t\tresults.defaultValue = columnConstraint.value;\r\n\t\t\t} else if(columnConstraint.name && columnConstraint.name == \"COLLATE\") {\r\n\t\t\t\tresults.collate = columnConstraint.value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\t},\r\n\r\n\tindexToDbInfo: function(tree) {\r\n\t\tvar result = {\r\n\t\t\ttableName: tree.tableName,\r\n\t\t\tname: tree.indexName,\r\n\t\t\tcolumns: tree.columns\r\n\t\t};\r\n\t\treturn result;\r\n\t},\r\n\r\n\tgetInfo: function(opts, callback) {\r\n\t\tvar self = this;\r\n\t\tvar db = opts.db;\r\n\t\tvar createdDb = false;\r\n\t  \tif(!db) {\r\n\t  \t\tdb = new sqlite3.Database(opts.filename);\r\n\t  \t\tcreatedDb = true;\r\n\t  \t}\r\n\r\n\t  \tdb.all(\"SELECT * FROM sqlite_master\", function(err, rows) {\r\n\t\t\t\tif(err) { callback(err); return; }\r\n\r\n\t\t\t\tvar results = {\r\n\t\t\t\t\ttables: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// clean up sql\r\n\t\t\t\tfor(var i=0; i<rows.length; i++) {\r\n\t\t\t\t\tif(rows[i]['sql'] && !rows[i]['sql'].match(/;$/)) {\r\n\t\t\t\t\t\trows[i]['sql'] += ';';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// process tables\r\n\t\t\t\tfor(var i=0; i<rows.length; i++) {\r\n\t\t\t\t\tif(rows[i]['type'] == 'table') {\r\n\t\t\t\t\t\tif(rows[i]['sql'].match(/sqlite_sequence/)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar tree = self.parseSql(rows[i]['sql']);\r\n\t\t\t\t\t\tresults.tables[tree.tableName] = self.tableToDbInfo(tree);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// process indexes\r\n\t\t\t\tfor(var i=0; i<rows.length; i++) {\r\n\t\t\t\t\tif(rows[i]['type'] == 'index' && rows[i]['sql']) {\r\n\t\t\t\t\t\tvar tree = self.parseSql(rows[i]['sql']);\r\n\t\t\t\t\t\tvar idx = self.indexToDbInfo(tree);\r\n\t\t\t\t\t\tresults.tables[idx.tableName].indexes[idx.name] = idx;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(createdDb) {\r\n\t\t\t\t\tdb.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallback(null, results);\r\n\t  \t});\r\n\t},\r\n\r\n\tparseSql: function(sql) {\r\n\t\tvar errorOffsets = new Array();\r\n\t\tvar errorLookaheads = new Array();\r\n\t\tvar errorCount = sqliteParser.parse(sql, errorOffsets, errorLookaheads);\r\n\r\n\t\tif(errorCount > 0)\r\n\t\t{\r\n\t\t\tvar errstr = \"\";\r\n\t\t\tfor(var i = 0; i < errorCount; i++) {\r\n\t\t\t\terrstr += 'Parse error near \"' + sql.substr(errorOffsets[i]) + '\", expecting \"' + errorLookaheads[i].join() + '\"\\n' + sql;\r\n\t\t\t}\r\n\t\t\tthrow new Error(errstr);\r\n\t\t} else {\r\n\t\t\treturn parserResult;\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = SqliteDriver;"]},"metadata":{},"sourceType":"script"}