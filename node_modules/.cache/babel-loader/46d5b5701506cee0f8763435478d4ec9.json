{"ast":null,"code":"var PriorityQueue = function (size) {\n  var me = {},\n      slots,\n      i,\n      total = null; // initialize arrays to hold queue elements\n\n  size = Math.max(+size | 0, 1);\n  slots = [];\n\n  for (i = 0; i < size; i += 1) {\n    slots.push([]);\n  } //  Public methods\n\n\n  me.size = function () {\n    var i;\n\n    if (total === null) {\n      total = 0;\n\n      for (i = 0; i < size; i += 1) {\n        total += slots[i].length;\n      }\n    }\n\n    return total;\n  };\n\n  me.enqueue = function (obj, priority) {\n    var priorityOrig; // Convert to integer with a default value of 0.\n\n    priority = priority && +priority | 0 || 0; // Clear cache for total.\n\n    total = null;\n\n    if (priority) {\n      priorityOrig = priority;\n\n      if (priority < 0 || priority >= size) {\n        priority = size - 1; // put obj at the end of the line\n\n        console.error(\"invalid priority: \" + priorityOrig + \" must be between 0 and \" + priority);\n      }\n    }\n\n    slots[priority].push(obj);\n  };\n\n  me.dequeue = function (callback) {\n    var obj = null,\n        i,\n        sl = slots.length; // Clear cache for total.\n\n    total = null;\n\n    for (i = 0; i < sl; i += 1) {\n      if (slots[i].length) {\n        obj = slots[i].shift();\n        break;\n      }\n    }\n\n    return obj;\n  };\n\n  return me;\n};\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @param {Object} factory\n *   Factory to be used for generating and destorying the items.\n * @param {String} factory.name\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.  Default: 1.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use). Default: 0.\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} factory.idleTimeoutMillis\n *   Delay in milliseconds after the idle items in the pool will be destroyed.\n *   And idle item is that is not acquired yet. Waiting items doesn't count here.\n * @param {Number} factory.reapIntervalMillis\n *   Cleanup is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} factory.log\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n * @param {Number} factory.priorityRange\n *   The range from 1 to be treated as a valid priority\n * @param {RefreshIdle} factory.refreshIdle\n *   Should idle resources be destroyed and recreated every idleTimeoutMillis? Default: true.\n * @returns {Object} An Object pool that works with the supplied `factory`.\n */\n\n\nexports.Pool = function (factory) {\n  var me = {},\n      idleTimeoutMillis = factory.idleTimeoutMillis || 30000,\n      reapInterval = factory.reapIntervalMillis || 1000,\n      refreshIdle = 'refreshIdle' in factory ? factory.refreshIdle : true,\n      availableObjects = [],\n      waitingClients = new PriorityQueue(factory.priorityRange || 1),\n      count = 0,\n      removeIdleScheduled = false,\n      removeIdleTimer = null,\n      draining = false,\n      // Prepare a logger function.\n  log = factory.log ? function (str, level) {\n    if (typeof factory.log === 'function') {\n      factory.log(str, level);\n    } else {\n      console.log(level.toUpperCase() + \" pool \" + factory.name + \" - \" + str);\n    }\n  } : function () {};\n\n  factory.validate = factory.validate || function () {\n    return true;\n  };\n\n  factory.max = parseInt(factory.max, 10);\n  factory.min = parseInt(factory.min, 10);\n  factory.max = Math.max(isNaN(factory.max) ? 1 : factory.max, 1);\n  factory.min = Math.min(isNaN(factory.min) ? 0 : factory.min, factory.max - 1); ///////////////\n\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} obj\n   *   The acquired item to be destoyed.\n   */\n\n  me.destroy = function (obj) {\n    count -= 1;\n    availableObjects = availableObjects.filter(function (objWithTimeout) {\n      return objWithTimeout.obj !== obj;\n    });\n    factory.destroy(obj);\n    ensureMinimum();\n  };\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   */\n\n\n  function removeIdle() {\n    var toRemove = [],\n        now = new Date().getTime(),\n        i,\n        al,\n        tr,\n        timeout;\n    removeIdleScheduled = false; // Go through the available (idle) items,\n    // check if they have timed out\n\n    for (i = 0, al = availableObjects.length; i < al && (refreshIdle || count - factory.min > toRemove.length); i += 1) {\n      timeout = availableObjects[i].timeout;\n\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, 'verbose');\n        toRemove.push(availableObjects[i].obj);\n      }\n    }\n\n    for (i = 0, tr = toRemove.length; i < tr; i += 1) {\n      me.destroy(toRemove[i]);\n    } // Replace the available items with the ones to keep.\n\n\n    al = availableObjects.length;\n\n    if (al > 0) {\n      log(\"availableObjects.length=\" + al, 'verbose');\n      scheduleRemoveIdle();\n    } else {\n      log(\"removeIdle() all objects removed\", 'verbose');\n    }\n  }\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n\n\n  function scheduleRemoveIdle() {\n    if (!removeIdleScheduled) {\n      removeIdleScheduled = true;\n      removeIdleTimer = setTimeout(removeIdle, reapInterval);\n    }\n  }\n  /**\n   * Handle callbacks with either the [obj] or [err, obj] arguments in an\n   * adaptive manner. Uses the `cb.length` property to determine the number\n   * of arguments expected by `cb`.\n   */\n\n\n  function adjustCallback(cb, err, obj) {\n    if (!cb) return;\n\n    if (cb.length <= 1) {\n      cb(obj);\n    } else {\n      cb(err, obj);\n    }\n  }\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, shift the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   */\n\n\n  function dispense() {\n    var obj = null,\n        objWithTimeout = null,\n        err = null,\n        clientCb = null,\n        waitingCount = waitingClients.size();\n    log(\"dispense() clients=\" + waitingCount + \" available=\" + availableObjects.length, 'info');\n\n    if (waitingCount > 0) {\n      while (availableObjects.length > 0) {\n        log(\"dispense() - reusing obj\", 'verbose');\n        objWithTimeout = availableObjects[0];\n\n        if (!factory.validate(objWithTimeout.obj)) {\n          me.destroy(objWithTimeout.obj);\n          continue;\n        }\n\n        availableObjects.shift();\n        clientCb = waitingClients.dequeue();\n        return clientCb(err, objWithTimeout.obj);\n      }\n\n      if (count < factory.max) {\n        createResource();\n      }\n    }\n  }\n\n  function createResource() {\n    count += 1;\n    log(\"createResource() - creating obj - count=\" + count + \" min=\" + factory.min + \" max=\" + factory.max, 'verbose');\n    factory.create(function () {\n      var err, obj;\n      var clientCb = waitingClients.dequeue();\n\n      if (arguments.length > 1) {\n        err = arguments[0];\n        obj = arguments[1];\n      } else {\n        err = arguments[0] instanceof Error ? arguments[0] : null;\n        obj = arguments[0] instanceof Error ? null : arguments[0];\n      }\n\n      if (err) {\n        count -= 1;\n\n        if (clientCb) {\n          clientCb(err, obj);\n        }\n\n        process.nextTick(function () {\n          dispense();\n        });\n      } else {\n        if (clientCb) {\n          clientCb(err, obj);\n        } else {\n          me.release(obj);\n        }\n      }\n    });\n  }\n\n  function ensureMinimum() {\n    var i, diff;\n\n    if (!draining && count < factory.min) {\n      diff = factory.min - count;\n\n      for (i = 0; i < diff; i++) {\n        createResource();\n      }\n    }\n  }\n  /**\n   * Request a new client. The callback will be called,\n   * when a new client will be availabe, passing the client to it.\n   *\n   * @param {Function} callback\n   *   Callback function to be called after the acquire is successful.\n   *   The function will receive the acquired item as the first parameter.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Object} `true` if the pool is not fully utilized, `false` otherwise.\n   */\n\n\n  me.acquire = function (callback, priority) {\n    if (draining) {\n      throw new Error(\"pool is draining and cannot accept work\");\n    }\n\n    waitingClients.enqueue(callback, priority);\n    dispense();\n    return count < factory.max;\n  };\n\n  me.borrow = function (callback, priority) {\n    log(\"borrow() is deprecated. use acquire() instead\", 'warn');\n    me.acquire(callback, priority);\n  };\n  /**\n   * Return the client to the pool, in case it is no longer required.\n   *\n   * @param {Object} obj\n   *   The acquired object to be put back to the pool.\n   */\n\n\n  me.release = function (obj) {\n    // check to see if this object has already been released (i.e., is back in the pool of availableObjects)\n    if (availableObjects.some(function (objWithTimeout) {\n      return objWithTimeout.obj === obj;\n    })) {\n      log(\"release called twice for the same resource: \" + new Error().stack, 'error');\n      return;\n    } //log(\"return to pool\");\n\n\n    var objWithTimeout = {\n      obj: obj,\n      timeout: new Date().getTime() + idleTimeoutMillis\n    };\n    availableObjects.push(objWithTimeout);\n    log(\"timeout: \" + objWithTimeout.timeout, 'verbose');\n    dispense();\n    scheduleRemoveIdle();\n  };\n\n  me.returnToPool = function (obj) {\n    log(\"returnToPool() is deprecated. use release() instead\", 'warn');\n    me.release(obj);\n  };\n  /**\n   * Disallow any new requests and let the request backlog dissapate.\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked when all work is done and all clients have been\n   *   released.\n   */\n\n\n  me.drain = function (callback) {\n    log(\"draining\", 'info'); // disable the ability to put more work on the queue.\n\n    draining = true;\n\n    var check = function () {\n      if (waitingClients.size() > 0) {\n        // wait until all client requests have been satisfied.\n        setTimeout(check, 100);\n      } else if (availableObjects.length != count) {\n        // wait until all objects have been released.\n        setTimeout(check, 100);\n      } else {\n        if (callback) {\n          callback();\n        }\n      }\n    };\n\n    check();\n  };\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked after all existing clients are destroyed.\n   */\n\n\n  me.destroyAllNow = function (callback) {\n    log(\"force destroying all objects\", 'info');\n    var willDie = availableObjects;\n    availableObjects = [];\n    var obj = willDie.shift();\n\n    while (obj !== null && obj !== undefined) {\n      me.destroy(obj.obj);\n      obj = willDie.shift();\n    }\n\n    removeIdleScheduled = false;\n    clearTimeout(removeIdleTimer);\n\n    if (callback) {\n      callback();\n    }\n  };\n  /**\n   * Decorates a function to use a acquired client from the object pool when called.\n   *\n   * @param {Function} decorated\n   *   The decorated function, accepting a client as the first argument and \n   *   (optionally) a callback as the final argument.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   */\n\n\n  me.pooled = function (decorated, priority) {\n    return function () {\n      var callerArgs = arguments;\n      var callerCallback = callerArgs[callerArgs.length - 1];\n      var callerHasCallback = typeof callerCallback === 'function';\n      me.acquire(function (err, client) {\n        if (err) {\n          if (callerHasCallback) {\n            callerCallback(err);\n          }\n\n          return;\n        }\n\n        var args = [client].concat(Array.prototype.slice.call(callerArgs, 0, callerHasCallback ? -1 : undefined));\n        args.push(function () {\n          me.release(client);\n\n          if (callerHasCallback) {\n            callerCallback.apply(null, arguments);\n          }\n        });\n        decorated.apply(null, args);\n      }, priority);\n    };\n  };\n\n  me.getPoolSize = function () {\n    return count;\n  };\n\n  me.getName = function () {\n    return factory.name;\n  };\n\n  me.availableObjectsCount = function () {\n    return availableObjects.length;\n  };\n\n  me.waitingClientsCount = function () {\n    return waitingClients.size();\n  }; // create initial resources (if factory.min > 0)\n\n\n  ensureMinimum();\n  return me;\n};","map":{"version":3,"sources":["C:/Users/adamj/OneDrive/Desktop/crwn-clothing-app/node_modules/generic-pool/lib/generic-pool.js"],"names":["PriorityQueue","size","me","slots","i","total","Math","max","push","length","enqueue","obj","priority","priorityOrig","console","error","dequeue","callback","sl","shift","exports","Pool","factory","idleTimeoutMillis","reapInterval","reapIntervalMillis","refreshIdle","availableObjects","waitingClients","priorityRange","count","removeIdleScheduled","removeIdleTimer","draining","log","str","level","toUpperCase","name","validate","parseInt","min","isNaN","destroy","filter","objWithTimeout","ensureMinimum","removeIdle","toRemove","now","Date","getTime","al","tr","timeout","scheduleRemoveIdle","setTimeout","adjustCallback","cb","err","dispense","clientCb","waitingCount","createResource","create","arguments","Error","process","nextTick","release","diff","acquire","borrow","some","stack","returnToPool","drain","check","destroyAllNow","willDie","undefined","clearTimeout","pooled","decorated","callerArgs","callerCallback","callerHasCallback","client","args","concat","Array","prototype","slice","call","apply","getPoolSize","getName","availableObjectsCount","waitingClientsCount"],"mappings":"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","sourcesContent":["var PriorityQueue = function(size) {\n  var me = {}, slots, i, total = null;\n\n  // initialize arrays to hold queue elements\n  size = Math.max(+size | 0, 1);\n  slots = [];\n  for (i = 0; i < size; i += 1) {\n    slots.push([]);\n  }\n\n  //  Public methods\n  me.size = function () {\n    var i;\n    if (total === null) {\n      total = 0;\n      for (i = 0; i < size; i += 1) {\n        total += slots[i].length;\n      }\n    }\n    return total;\n  };\n\n  me.enqueue = function (obj, priority) {\n    var priorityOrig;\n\n    // Convert to integer with a default value of 0.\n    priority = priority && + priority | 0 || 0;\n\n    // Clear cache for total.\n    total = null;\n    if (priority) {\n      priorityOrig = priority;\n      if (priority < 0 || priority >= size) {\n        priority = (size - 1);\n        // put obj at the end of the line\n        console.error(\"invalid priority: \" + priorityOrig + \" must be between 0 and \" + priority);\n      }\n    }\n\n    slots[priority].push(obj);\n  };\n\n  me.dequeue = function (callback) {\n    var obj = null, i, sl = slots.length;\n\n    // Clear cache for total.\n    total = null;\n    for (i = 0; i < sl; i += 1) {\n      if (slots[i].length) {\n        obj = slots[i].shift();\n        break;\n      }\n    }\n    return obj;\n  };\n\n  return me;\n};\n\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @param {Object} factory\n *   Factory to be used for generating and destorying the items.\n * @param {String} factory.name\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.  Default: 1.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use). Default: 0.\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} factory.idleTimeoutMillis\n *   Delay in milliseconds after the idle items in the pool will be destroyed.\n *   And idle item is that is not acquired yet. Waiting items doesn't count here.\n * @param {Number} factory.reapIntervalMillis\n *   Cleanup is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} factory.log\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n * @param {Number} factory.priorityRange\n *   The range from 1 to be treated as a valid priority\n * @param {RefreshIdle} factory.refreshIdle\n *   Should idle resources be destroyed and recreated every idleTimeoutMillis? Default: true.\n * @returns {Object} An Object pool that works with the supplied `factory`.\n */\nexports.Pool = function (factory) {\n  var me = {},\n\n      idleTimeoutMillis = factory.idleTimeoutMillis || 30000,\n      reapInterval = factory.reapIntervalMillis || 1000,\n      refreshIdle = ('refreshIdle' in factory) ? factory.refreshIdle : true,\n      availableObjects = [],\n      waitingClients = new PriorityQueue(factory.priorityRange || 1),\n      count = 0,\n      removeIdleScheduled = false,\n      removeIdleTimer = null,\n      draining = false,\n\n      // Prepare a logger function.\n      log = factory.log ?\n        (function (str, level) {\n           if (typeof factory.log === 'function') {\n             factory.log(str, level);\n           }\n           else {\n             console.log(level.toUpperCase() + \" pool \" + factory.name + \" - \" + str);\n           }\n         }\n        ) :\n        function () {};\n\n  factory.validate = factory.validate || function() { return true; };\n        \n  factory.max = parseInt(factory.max, 10);\n  factory.min = parseInt(factory.min, 10);\n  \n  factory.max = Math.max(isNaN(factory.max) ? 1 : factory.max, 1);\n  factory.min = Math.min(isNaN(factory.min) ? 0 : factory.min, factory.max-1);\n  \n  ///////////////\n\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} obj\n   *   The acquired item to be destoyed.\n   */\n  me.destroy = function(obj) {\n    count -= 1;\n    availableObjects = availableObjects.filter(function(objWithTimeout) {\n              return (objWithTimeout.obj !== obj);\n    });\n    factory.destroy(obj);\n    \n    ensureMinimum();\n  };\n\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   */\n  function removeIdle() {\n    var toRemove = [],\n        now = new Date().getTime(),\n        i,\n        al, tr,\n        timeout;\n\n    removeIdleScheduled = false;\n\n    // Go through the available (idle) items,\n    // check if they have timed out\n    for (i = 0, al = availableObjects.length; i < al && (refreshIdle || (count - factory.min > toRemove.length)); i += 1) {\n      timeout = availableObjects[i].timeout;\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, 'verbose');\n        toRemove.push(availableObjects[i].obj);\n      } \n    }\n\n    for (i = 0, tr = toRemove.length; i < tr; i += 1) {\n      me.destroy(toRemove[i]);\n    }\n\n    // Replace the available items with the ones to keep.\n    al = availableObjects.length;\n\n    if (al > 0) {\n      log(\"availableObjects.length=\" + al, 'verbose');\n      scheduleRemoveIdle();\n    } else {\n      log(\"removeIdle() all objects removed\", 'verbose');\n    }\n  }\n\n\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n  function scheduleRemoveIdle() {\n    if (!removeIdleScheduled) {\n      removeIdleScheduled = true;\n      removeIdleTimer = setTimeout(removeIdle, reapInterval);\n    }\n  }\n\n  /**\n   * Handle callbacks with either the [obj] or [err, obj] arguments in an\n   * adaptive manner. Uses the `cb.length` property to determine the number\n   * of arguments expected by `cb`.\n   */\n  function adjustCallback(cb, err, obj) {\n    if (!cb) return;\n    if (cb.length <= 1) {\n      cb(obj);\n    } else {\n      cb(err, obj);\n    }\n  }\n\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, shift the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   */\n  function dispense() {\n    var obj = null,\n        objWithTimeout = null,\n        err = null,\n        clientCb = null,\n        waitingCount = waitingClients.size();\n        \n    log(\"dispense() clients=\" + waitingCount + \" available=\" + availableObjects.length, 'info');\n    if (waitingCount > 0) {\n      while (availableObjects.length > 0) {\n        log(\"dispense() - reusing obj\", 'verbose');\n        objWithTimeout = availableObjects[0];\n        if (!factory.validate(objWithTimeout.obj)) {\n          me.destroy(objWithTimeout.obj);\n          continue;\n        }\n        availableObjects.shift();\n        clientCb = waitingClients.dequeue();\n        return clientCb(err, objWithTimeout.obj);\n      }\n      if (count < factory.max) {\n        createResource();\n      }\n    }\n  }\n  \n  function createResource() {\n    count += 1;\n    log(\"createResource() - creating obj - count=\" + count + \" min=\" + factory.min + \" max=\" + factory.max, 'verbose');\n    factory.create(function () {\n      var err, obj;\n      var clientCb = waitingClients.dequeue();\n      if (arguments.length > 1) {\n        err = arguments[0];\n        obj = arguments[1];\n      } else {\n        err = (arguments[0] instanceof Error) ? arguments[0] : null;\n        obj = (arguments[0] instanceof Error) ? null : arguments[0];\n      }\n      if (err) {\n        count -= 1;\n        if (clientCb) {\n          clientCb(err, obj);\n        }\n        process.nextTick(function(){\n          dispense();\n        });\n      } else {\n        if (clientCb) {\n          clientCb(err, obj);\n        } else {\n          me.release(obj);\n        }\n      }\n    });\n  }\n  \n  function ensureMinimum() {\n    var i, diff;\n    if (!draining && (count < factory.min)) {\n      diff = factory.min - count;\n      for (i = 0; i < diff; i++) {\n        createResource();\n      }\n    }\n  }\n\n  /**\n   * Request a new client. The callback will be called,\n   * when a new client will be availabe, passing the client to it.\n   *\n   * @param {Function} callback\n   *   Callback function to be called after the acquire is successful.\n   *   The function will receive the acquired item as the first parameter.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Object} `true` if the pool is not fully utilized, `false` otherwise.\n   */\n  me.acquire = function (callback, priority) {\n    if (draining) {\n      throw new Error(\"pool is draining and cannot accept work\");\n    }\n    waitingClients.enqueue(callback, priority);\n    dispense();\n    return (count < factory.max);\n  };\n\n  me.borrow = function (callback, priority) {\n    log(\"borrow() is deprecated. use acquire() instead\", 'warn');\n    me.acquire(callback, priority);\n  };\n\n  /**\n   * Return the client to the pool, in case it is no longer required.\n   *\n   * @param {Object} obj\n   *   The acquired object to be put back to the pool.\n   */\n  me.release = function (obj) {\n\t// check to see if this object has already been released (i.e., is back in the pool of availableObjects)\n    if (availableObjects.some(function(objWithTimeout) { return (objWithTimeout.obj === obj); })) {\n      log(\"release called twice for the same resource: \" + (new Error().stack), 'error');\n      return;\n    }\n    //log(\"return to pool\");\n    var objWithTimeout = { obj: obj, timeout: (new Date().getTime() + idleTimeoutMillis) };\n    availableObjects.push(objWithTimeout);\n    log(\"timeout: \" + objWithTimeout.timeout, 'verbose');\n    dispense();\n    scheduleRemoveIdle();\n  };\n\n  me.returnToPool = function (obj) {\n    log(\"returnToPool() is deprecated. use release() instead\", 'warn');\n    me.release(obj);\n  };\n\n  /**\n   * Disallow any new requests and let the request backlog dissapate.\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked when all work is done and all clients have been\n   *   released.\n   */\n  me.drain = function(callback) {\n    log(\"draining\", 'info');\n\n    // disable the ability to put more work on the queue.\n    draining = true;\n\n    var check = function() {\n      if (waitingClients.size() > 0) {\n        // wait until all client requests have been satisfied.\n        setTimeout(check, 100);\n      } else if (availableObjects.length != count) {\n        // wait until all objects have been released.\n        setTimeout(check, 100);\n      } else {\n        if (callback) {\n          callback();\n        }\n      }\n    };\n    check();\n  };\n\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @param {Function} callback\n   *   Optional. Callback invoked after all existing clients are destroyed.\n   */\n  me.destroyAllNow = function(callback) {\n    log(\"force destroying all objects\", 'info');\n    var willDie = availableObjects;\n    availableObjects = [];\n    var obj = willDie.shift();\n    while (obj !== null && obj !== undefined) {\n      me.destroy(obj.obj);\n      obj = willDie.shift();\n    }\n    removeIdleScheduled = false;\n    clearTimeout(removeIdleTimer);\n    if (callback) {\n      callback();\n    }\n  };\n\n  /**\n   * Decorates a function to use a acquired client from the object pool when called.\n   *\n   * @param {Function} decorated\n   *   The decorated function, accepting a client as the first argument and \n   *   (optionally) a callback as the final argument.\n   *\n   * @param {Number} priority\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   */\n  me.pooled = function(decorated, priority) {\n    return function() {\n      var callerArgs = arguments;\n      var callerCallback = callerArgs[callerArgs.length - 1];\n      var callerHasCallback = typeof callerCallback === 'function';\n      me.acquire(function(err, client) {\n        if(err) {\n          if(callerHasCallback) {\n            callerCallback(err);\n          }\n          return;\n        }\n\n        var args = [client].concat(Array.prototype.slice.call(callerArgs, 0, callerHasCallback ? -1 : undefined));\n        args.push(function() {\n          me.release(client);\n          if(callerHasCallback) {\n            callerCallback.apply(null, arguments);\n          }\n        });\n        \n        decorated.apply(null, args);\n      }, priority);\n    };\n  };\n\n  me.getPoolSize = function() {\n    return count;\n  };\n\n  me.getName = function() {\n    return factory.name;\n  };\n\n  me.availableObjectsCount = function() {\n    return availableObjects.length;\n  };\n\n  me.waitingClientsCount = function() {\n    return waitingClients.size();\n  };\n\n\n  // create initial resources (if factory.min > 0)\n  ensureMinimum();\n\n  return me;\n};\n"]},"metadata":{},"sourceType":"script"}